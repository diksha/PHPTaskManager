<?php
class Thread
{
    const BLOCKING = 1;
    const NON_BLOCKING = 0;

    private $resource;          //process resource handler
    private $cwd;               //The initial working dir for the command. This must be an absolute directory path, or NULL
    private $command;
    private $pid_path = '/proc/';
    private $pipes = array();   //Will be set to an indexed array of file pointers that correspond to PHP's end of any pipes that are created.  
    private $env = array();     //An array with the environment variables for the command that will be run, or NULL to use the same environment as the current PHP process 
    private $stream_set_blocking = true;

    private $descriptorspec = array(
        0 => array("pipe", "r"),  // stdin is a pipe that the child will read from
        1 => array("pipe", "w"),  // stdout is a pipe that the child will write to
        2 => array("pipe", "w") // stderr is a file to write to
    );

    private $other_options = array(
        'supress_errors' => false,  //suppress_errors (windows only): suppresses errors generated by this function when it's set to TRUE
        'bypass_shell' => false,    //bypass_shell (windows only): bypass cmd.exe shell when set to TRUE
        'context' => false,         //context: stream context used when opening files (created with stream_context_create())
        'binary_pipes' => false     //binary_pipes: open pipes in binary mode, instead of using the usual stream_encoding
    );

    
    public function setCommand($command) {
        $this->command = $command;
    }

    public function setLogFile($file) {
        $this->descriptorspec[1] = array("file", $file, 'w');
        $this->descriptorspec[2] = array("file", $file, 'w');
        $this->stream_set_blocking = false;
    }

    public function execute() {
        $this->resource = proc_open($this->command, $this->descriptorspec, $this->pipes, $this->cwd, $this->env, $this->other_options);

        if($this->stream_set_blocking)
            $block = self::BLOCKING;
        else
            $block = self::NON_BLOCKING;

        if(isset($this->pipes[1]))
            stream_set_blocking($this->pipes[1], $block);

        if(isset($this->pipes[2]))
            stream_set_blocking($this->pipes[2], $block);
    }

    public function __destruct() {
        if($this->resource)
            proc_close($this->resource);
    }

    public function getStatus() {
        return proc_get_status($this->resource);
    }

    public function read() {
        return fgets($this->pipes[1]);
    }

    public function isRunning() {
        $status = $this->getStatus();
        return $status['running'];
    }

    public function getProcessId() {
        $status = $this->getStatus();
        return $status['pid'];
    }

    private function log($msg) {
        print_r($msg."\n");
    }

    public function getCommand() {
        return $this->command;
    }
}
